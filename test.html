<html>
<head>
  <title>LeapViz</title>
  <script src="three.min.js"></script>
  <script src="leap-0.6.2.js"></script>
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
  <script>
    function reset() {
      console.log("resetting map");
      mapLoc = {lat: 40.022482, lon: -75.108077, zoom: 11} // resets to philadelphia
      loadMap(mapLoc);
    }
  </script>
</head>
<body>
  <button type="button" onClick="reset()">Reset map</button>
  <div id="coordinates"></div>
  <script>
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 10000);
    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

		Array.matrix = function(numrows, numcols, initial){
			 var arr = [];
			 for (var i = 0; i < numrows; ++i){
					var columns = [];
					for (var j = 0; j < numcols; ++j){
						 columns[j] = initial;
					}
					arr[i] = columns;
				}
				return arr;
		}
    
    THREE.ImageUtils.crossOrigin = "anonymous";
    var img = new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture('http://maps.googleapis.com/maps/api/staticmap?center=40.714728,-73.998672&zoom=12&size=400x400')});
    img.map.needsUpdate = true;
    var plane = new THREE.Mesh(new THREE.PlaneGeometry(640,640), img);
    plane.overdraw = true;
    scene.add(plane);
   
    var NUM_ROWS = 100;
    var TILE_H = 640;
    var TILE_W = 640;
    var MAX_X = TILE_W/2;
    var MIN_X = - TILE_W/2;
    var MAX_Y = TILE_H/2;
    var MIN_Y = - TILE_H/2;
    var NORMAL_DIST = 400;
    var MIN_DIST = 300;
    var MAX_DIST = 600;

    // function to populate heat map
    function getDataPoints(x1, x2, y1, y2) {
      var rowSize = (y2 - y1) / NUM_ROWS;
      var colSize = (x2 - x1) / NUM_ROWS;
      var dataPoints = Array.matrix(NUM_ROWS, NUM_ROWS, 0);
      var x;
      var y;
      var arr = JSON;
      for (var i = 0; i < JSON.length; i++) {
        x = Math.floor((JSON[i].POINT_X - x1) / colSize);
        y = Math.floor((JSON[i].POINT_Y - y1) / rowSize);
        dataPoints[x][y]++;
      }
    }

    var sphereGeom = new THREE.SphereGeometry(3, 3, 2);
    var heatColors = [0xffffb2, 0xfecc5c, 0xfd8d3c, 0xf03b20, 0xbd0026];
    var sphereMat = [];
		//TODO: obtain bounds and query database
		//var data = getDataPoints(x1,x2,y1,y2);
    for (var i = 0; i < 5; i++) sphereMat[i] = new THREE.MeshBasicMaterial({color: heatColors[i]});
    for (var i = -50; i < 50; i++) {
      for (var j = -50; j < 50; j++) {
        var zVal = Math.exp(-(i*i + j*j)/1000)*300;
//		 		var zVal = data[i + 50][j + 50];
        var k = Math.round(zVal / 70);
        var sphere = new THREE.Mesh(sphereGeom, sphereMat[k]);
        sphere.position.x = i * (TILE_H / (NUM_ROWS*1.0));
        sphere.position.y = j * (TILE_W / (NUM_ROWS*1.0));
        sphere.position.z = zVal;
        scene.add(sphere);
      }
    }

    function updateMap() {
      var hasChanged = false;
      if (lookAtPoint.x > MAX_X) {
        lookAtPoint.x -= TILE_W/2;
        mapLocation.lon = getBounds(mapLocation, TILE_H, TILE_W).rightLon;
        hasChanged = true;
      }
      if (lookAtPoint.x < MIN_X) {
        lookAtPoint.x += TILE_W/2;
        mapLocation.lon = getBounds(mapLocation, TILE_H, TILE_W).leftLon;
        hasChanged = true;
      }
      if (lookAtPoint.y > MAX_Y) {
        lookAtPoint.y -= TILE_H/2;
        mapLocation.lat = getBounds(mapLocation, TILE_H, TILE_W).upLat;
        hasChanged = true;
      }
      if (lookAtPoint.y < MIN_Y) {
        lookAtPoint.y += TILE_H/2;
        mapLocation.lat = getBounds(mapLocation, TILE_H, TILE_W).downLat;
        hasChanged = true;
      }
      if (cameraDelta.d < MIN_DIST) {
        mapLocation.zoom++;
        lookAtPoint.x *= 2;
        lookAtPoint.y *= 2;
        cameraDelta.d *= 2;
        hasChanged = true;
      }
      if (cameraDelta.d > MAX_DIST) {
        mapLocation.zoom--;
        lookAtPoint.x /= 2;
        lookAtPoint.y /= 2;
        cameraDelta.d /= 2;
        hasChanged = true;
      }
      if (hasChanged) {
        loadMap(mapLocation);
      }
    }

    function updateCamera() {
      camera.position.z = lookAtPoint.z + cameraDelta.d * Math.sin(cameraDelta.elevation);;
      camera.position.y = lookAtPoint.y + Math.cos(cameraDelta.heading)*Math.cos(cameraDelta.elevation)*cameraDelta.d;
      camera.position.x = lookAtPoint.x + Math.sin(cameraDelta.heading)*Math.cos(cameraDelta.elevation)*cameraDelta.d;
      camera.up = new THREE.Vector3(0,0,1);
      camera.lookAt(new THREE.Vector3(lookAtPoint.x, lookAtPoint.y, lookAtPoint.z));
    }

    function getBounds(mapLoc, h, w) {
      var lon = mapLoc.lon, lat = mapLoc.lat, zoom = mapLoc.zoom;
      return {
        leftLon: lon - (360 * w) / Math.pow(2, 9+zoom),
        rightLon: lon + (360 * w) / Math.pow(2, 9+zoom),
        downLat: 180 * Math.asin(Math.sin(lat * Math.PI / 180) - h / Math.pow(2, 7+zoom))/Math.PI,
        upLat: 180 * Math.asin(Math.sin(lat * Math.PI / 180) + h / Math.pow(2, 7+zoom))/Math.PI,
      };
    }
    function loadMap(mapLoc) {
      console.log(mapLoc);
      img.map = THREE.ImageUtils.loadTexture('http://maps.googleapis.com/maps/api/staticmap?center=' + mapLoc.lat + ',' + mapLoc.lon + '&zoom=' + mapLoc.zoom + '&size=640x640&key='+API_KEY);
      img.map.needsUpdate = true;
    }
    var mapLocation = {lat: 40.022482, lon: -75.108077, zoom: 11};
    var API_KEY = "AIzaSyB6PUUj1nfpIUw3gmF2e0s5AaoZe-CFyRA";
    var lookAtPoint = {x: 0, y: 50, z: 0};
    var cameraDelta = {d: 400, elevation: 45 * (Math.PI / 180), heading: 270 * (Math.PI / 180)};
    loadMap(mapLocation);
    updateCamera();

    var ambientLight = new THREE.AmbientLight(0x555555);
    scene.add(ambientLight);

    // speed of frame changing
    var MOVESPEED = 20;
    var SCROLLSPEED = 20;
    var ROTATESPEED = 0.1;
    var ZOOMSPEED = 10;
    var ROTATEFRONTBACKSPEED = 0.005;

    function clamp(mn, val, mx) {
      return Math.min(mx, Math.max(val, mn));
    }
    function panLeft(speed) {
      lookAtPoint.x += speed * Math.cos(cameraDelta.heading);
      lookAtPoint.y -= speed * Math.sin(cameraDelta.heading);
    }
    function panRight(speed) {
      lookAtPoint.x -= speed * Math.cos(cameraDelta.heading);
      lookAtPoint.y += speed * Math.sin(cameraDelta.heading);
    }
    function panForward(speed) {
      lookAtPoint.x -= speed * Math.sin(cameraDelta.heading);
      lookAtPoint.y -= speed * Math.cos(cameraDelta.heading);
    }
    function panBackward(speed) {
      lookAtPoint.x += speed * Math.sin(cameraDelta.heading);
      lookAtPoint.y += speed * Math.cos(cameraDelta.heading);
    }
    function rotateUp(angle) {
      cameraDelta.elevation = clamp(10 * (Math.PI/180), cameraDelta.elevation + angle, 80 * (Math.PI/180));
    }
    function rotateDown(angle) {
      cameraDelta.elevation = clamp(10 * (Math.PI/180), cameraDelta.elevation - angle, 80 * (Math.PI/180));
    }
    function rotateLeft(angle) {
      cameraDelta.heading += 0.1;
    }
    function rotateRight(angle) {
      cameraDelta.heading -= 0.1;
    }
    function zoomIn(speed) {
      cameraDelta.d = clamp(30, cameraDelta.d-speed, 1500);
    }
    function zoomOut(speed) {
      cameraDelta.d = clamp(30, cameraDelta.d+speed, 1500);
    }

    // variables to use in the leap loop
    var previousFrame = null;
    var performedAction = false;
    var info, palm, phalanges = [];

    function initPalm() {
      console.log("initializing palm");
      // palm
      geometry = new THREE.BoxGeometry( 80, 20, 80 );
      geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0, -30 ) );  // to to +30 if using pitch roll & yaw
      material = new THREE.MeshNormalMaterial();
      palm = new THREE.Mesh( geometry, material );
      palm.castShadow = true;
      palm.receiveShadow = true;
      scene.add( palm );
    }
    function initPhalanges() {
      // phalanges
      geometry = new THREE.BoxGeometry( 16, 12, 1 );
      for ( var i = 0; i < 15; i++) {
        mesh = new THREE.Mesh( geometry, material );
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        scene.add( mesh );
        phalanges.push( mesh );
      }
    }
    initPalm();
    initPhalanges();

    // TODO: LLH
    function performAction(x, y) {
      alert("selected point at " + x + ", " + y);
    }

    Leap.loop({enableGestures: true}, function(frame) {
      console.log("inside loop");
      // DRAWING OF HAND TO ACT AS CURSOR
      var hand, phalanx, point, length;
      if ( frame.hands.length ) {
        hand = frame.hands[0];
        palm.position.set( hand.palmPosition[0], hand.palmPosition[1], hand.palmPosition[2] );
        direction = new THREE.Vector3( hand.direction[0], hand.direction[1], hand.direction[2] );  // best so far
        palm.lookAt( direction.add( palm.position ) );
        palm.rotation.z = -hand.roll();
      }
      iLen = ( frame.pointables.length < 5 ) ? frame.pointables.length : 5;
      for (var i = 0; i < iLen; i++) {
        for ( var j = 0; j < 3; j++) {
          phalanx = phalanges[ 3 * i + j];
          if (frame.pointables[i].positions) {
            point = frame.pointables[i].positions[j];
            phalanx.position.set( point[0], point[1], point[2] );
            point = frame.pointables[i].positions[ j + 1 ];
            point = new THREE.Vector3( point[0], point[1], point[2] );
            phalanx.lookAt( point );
            length = phalanx.position.distanceTo( point );
            phalanx.translateZ( 0.5 * length );
            phalanx.scale.set( 1, 1, length );
          }
        }
      }

      // MAIN GESTURE RECOGNITION
      if (previousFrame && previousFrame.valid) {
        var translation = frame.translation(previousFrame);
        var rotationAxis = frame.rotationAxis(previousFrame);
        var rotationAngle = frame.rotationAngle(previousFrame);

        if (frame.hands.length == 1) { // detect one hand
          // actions allowed: rotation, tilt and selection
          var hand = frame.hands[0];
          if (hand) {
            var pitch = hand.pitch();
            var yaw = hand.yaw();
            var roll = hand.roll();  

            // output hand position
            var handPosition = hand.palmPosition;
            var posString = "(" + handPosition[0] + ", " + handPosition[1] + ", " + handPosition[2] + ")" 
            var handOutput = document.getElementById("coordinates");
            handOutput.innerHTML = posString;
          }
          if (frame.pointables.length > 0) { // check for how many fingers are extended
            var countFingersExtended = 0;
            for (var i = 0; i < frame.pointables.length; i++) {
              var pointable = frame.pointables[i];
              if (pointable.extended && !pointable.tool) {
                countFingersExtended++;
              }
            }
            console.log("number of fingers extended: " + countFingersExtended);
          }
          // perform rotate up and down if it detects circles
          if (frame.gestures.length > 0) {
            var gestureString = "";
            for (var i = 0; i < frame.gestures.length; i++) {
              var gesture = frame.gestures[i];
              if (gesture.type == "circle") {
                var clockwise = false;
                var pointableID = gesture.pointableIds[0];
                var direction = frame.pointable(pointableID).direction;
                var dotProduct = Leap.vec3.dot(direction, gesture.normal);
                if (dotProduct  >  0) clockwise = true;
                if (clockwise) {
                  rotateUp(ROTATEFRONTBACKSPEED);
                } else {
                  rotateDown(ROTATEFRONTBACKSPEED);
                }
              } else if (gesture.type == "screenTap") { // check for screen tap
                // var duration = gesture.duration; 
                console.log("performing selection");
                // get coordinates of location selected
                var currMapBounds = getBounds(mapLocation, TILE_H, TILE_W);
                var distLon = currMapBounds.rightLon - currMapBounds.leftLon;
                var distLat = currMapBounds.upLat - currMapBounds.downLat;
                if (hand) {
                  var handPosition = hand.palmPosition;
                  // TODO JEVON: change the hand bounds to not be half of the map only
                  var DIFF = 400.0;
                  var LOWER_X_BOUND = -200;
                  var LOWER_Y_BOUND = 0; 
                  var selectedLon = (((handPosition[0] - LOWER_Y_BOUND) / DIFF) * distLon) + currMapBounds.leftLon;
                  var selectedLat = (((handPosition[1] - LOWER_X_BOUND) / DIFF) * distLat) + currMapBounds.downLat;
                  performAction(selectedLat, selectedLon);
                }
              } else {
                console.log("unknown gesture type");
              }
            }
          } else if (countFingersExtended > 1) {
            if (roll > 0.5) { // tilt left
              panLeft(SCROLLSPEED);
              console.log("shifting left");
            } else if (roll < -0.5) { // tilt right
              panRight(SCROLLSPEED);
              console.log("shifting right");
            } else if (pitch > 0.5) { // tilt back
              panBackward(SCROLLSPEED);
              console.log("tilting backward");
            } else if (pitch < -0.5) { // tilt forward
              panForward(SCROLLSPEED);
              console.log("tilting forward");
            } else if (yaw < -0.5) { // rotating counterclockwise
              rotateLeft(ROTATESPEED);
            } else if (yaw > 0.5) { // rotating clockwise
              rotateRight(ROTATESPEED);
            }
          }
        } else if (frame.hands.length == 2) {
          // perform zooming in and out if two hands detected
          for (var i = 0; i < frame.hands.length; i++) {
            var hand = frame.hands[i];
            if (previousFrame && previousFrame.valid) {
              var translation = hand.translation(previousFrame);
              if ((hand.type == "right" && translation[0] > 0.5) || (hand.type == "left" && translation[0] < -0.5)) {
                // zooming out
                zoomOut(ZOOMSPEED);
                console.log("zooming out");
              } else if ((hand.type == "right" && translation[0] < -0.5) || (hand.type == "left" && translation[0] > 0.5)) {
                // zoom in
                zoomIn(ZOOMSPEED);
                console.log("zooming in");
              }
            }  
          }
        }
      }
      
      // Store frame for motion functions
      previousFrame = frame;
      updateMap();
      updateCamera();
    });

    $(document).keydown(function(e) {
      if (e.keyCode == 37) { // left
        panLeft(MOVESPEED);
      } else if (e.keyCode == 38) { // up
        panForward(MOVESPEED);
      } else if (e.keyCode == 39) { // right
        panRight(MOVESPEED);
      } else if (e.keyCode == 40) { // down
        panBackward(MOVESPEED);
      } else if (e.keyCode == 87) { // W
        rotateUp(0.1);
      } else if (e.keyCode == 83) { // S
        rotateDown(0.1);
      } else if (e.keyCode == 65) { // A
        rotateLeft(0.1);
        //cameraDelta.angle += 0.1;
      } else if (e.keyCode == 68) { // D
        rotateRight(0.1);
        //cameraDelta.angle -= 0.1;
      } else if (e.keyCode == 81) { // Q
        zoomIn(MOVESPEED);
      } else if (e.keyCode == 69) { // E
        zoomOut(MOVESPEED);
      } else if (e.keyCode == 70) { // F
        var bounds = getBounds(mapLocation,TILE_H,TILE_W);
        mapLocation.lon = bounds.rightLon;
        loadMap(mapLocation);
      } else if (e.keyCode == 76) { // L
        performAction(40.022482, -75.108077); // hardcoded coords for testing
      } else {
        return;
      }
      updateMap();
      updateCamera();
      e.preventDefault();
    });

    var render = function() {
      requestAnimationFrame(render);
       
      //plane.rotation.z += 0.01;

      renderer.render(scene, camera);
    };
    render();
  </script>
</body>
</html>
